# API Reference

*Auto-generated by verus-docgenerator*

## `mat3::ops`

### Spec Functions

- **`open spec fn identity`** — [mat3/ops.rs:15](./src/mat3/ops.rs#L15)
- **`open spec fn mat_vec_mul`** — [mat3/ops.rs:23](./src/mat3/ops.rs#L23)
- **`open spec fn transpose`** — [mat3/ops.rs:27](./src/mat3/ops.rs#L27)
- **`open spec fn det`** — [mat3/ops.rs:35](./src/mat3/ops.rs#L35)
- **`open spec fn mat_mul`** — [mat3/ops.rs:39](./src/mat3/ops.rs#L39)

### Proof Functions

- **`proof fn lemma_transpose_involution`** — [mat3/ops.rs:65](./src/mat3/ops.rs#L65)
  > transpose(transpose(m)) ≡ m  (structurally identical, just needs reflexivity)
- **`proof fn lemma_mat_vec_mul_zero`** — [mat3/ops.rs:87](./src/mat3/ops.rs#L87)
  > mat_vec_mul(m, zero) ≡ zero
- **`proof fn lemma_mat_vec_mul_add`** — [mat3/ops.rs:99](./src/mat3/ops.rs#L99)
  > mat_vec_mul(m, a + b) ≡ mat_vec_mul(m, a) + mat_vec_mul(m, b)
- **`proof fn lemma_mat_vec_mul_scale`** — [mat3/ops.rs:111](./src/mat3/ops.rs#L111)
  > mat_vec_mul(m, scale(s, v)) ≡ scale(s, mat_vec_mul(m, v))
- **`proof fn lemma_identity_mul_vec`** — [mat3/ops.rs:245](./src/mat3/ops.rs#L245)
  > mat_vec_mul(identity(), v) ≡ v
- **`proof fn lemma_det_swap_rows_01`** — [mat3/ops.rs:259](./src/mat3/ops.rs#L259)
  > det(swap rows 0,1) ≡ -det(m)
- **`proof fn lemma_det_swap_rows_12`** — [mat3/ops.rs:294](./src/mat3/ops.rs#L294)
  > det(swap rows 1,2) ≡ -det(m)
- **`proof fn lemma_det_cyclic`** — [mat3/ops.rs:305](./src/mat3/ops.rs#L305)
  > det(cyclic permutation of rows) ≡ det(m)
- **`proof fn lemma_det_zero_repeated_row_01`** — [mat3/ops.rs:317](./src/mat3/ops.rs#L317)
  > det(m) ≡ 0 when two rows are the same (rows 0,1)
- **`proof fn lemma_det_zero_repeated_row_12`** — [mat3/ops.rs:325](./src/mat3/ops.rs#L325)
  > det(m) ≡ 0 when two rows are the same (rows 1,2)
- **`proof fn lemma_det_linear_first_row`** — [mat3/ops.rs:333](./src/mat3/ops.rs#L333)
  > det is linear in the first row
- **`proof fn lemma_identity_mat_mul_left`** — [mat3/ops.rs:349](./src/mat3/ops.rs#L349)
  > mat_mul(identity(), m).row_i ≡ m.row_i
- **`proof fn lemma_identity_mat_mul_right`** — [mat3/ops.rs:371](./src/mat3/ops.rs#L371)
  > mat_mul(m, identity()).row_i ≡ m.row_i

## `vec2::Vec2<T>`

### Spec Functions

- **`open spec fn new`** — [vec2.rs:15](./src/vec2.rs#L15)

## `vec2::ops`

### Spec Functions

- **`open spec fn scale`** — [vec2/ops.rs:19](./src/vec2/ops.rs#L19)
- **`open spec fn dot`** — [vec2/ops.rs:23](./src/vec2/ops.rs#L23)
- **`open spec fn norm_sq`** — [vec2/ops.rs:27](./src/vec2/ops.rs#L27)
- **`open spec fn lerp`** — [vec2/ops.rs:31](./src/vec2/ops.rs#L31)
- **`open spec fn proj`** — [vec2/ops.rs:929](./src/vec2/ops.rs#L929)
  > Projection of a onto b
- **`open spec fn rej`** — [vec2/ops.rs:934](./src/vec2/ops.rs#L934)
  > Rejection of a from b (component of a orthogonal to b)
- **`open spec fn cwise_min`** — [vec2/ops.rs:1147](./src/vec2/ops.rs#L1147)
- **`open spec fn cwise_max`** — [vec2/ops.rs:1151](./src/vec2/ops.rs#L1151)

### Proof Functions

- **`proof fn lemma_scale_distributes_over_add`** — [vec2/ops.rs:40](./src/vec2/ops.rs#L40)
  > scale(s, a + b) ≡ scale(s, a) + scale(s, b)
- **`proof fn lemma_scale_add_distributes`** — [vec2/ops.rs:49](./src/vec2/ops.rs#L49)
  > scale(s + t, a) ≡ scale(s, a) + scale(t, a)
- **`proof fn lemma_scale_identity`** — [vec2/ops.rs:58](./src/vec2/ops.rs#L58)
  > scale(1, a) ≡ a
- **`proof fn lemma_scale_zero_scalar`** — [vec2/ops.rs:67](./src/vec2/ops.rs#L67)
  > scale(0, a) ≡ zero
- **`proof fn lemma_scale_zero_vec`** — [vec2/ops.rs:76](./src/vec2/ops.rs#L76)
  > scale(s, zero) ≡ zero
- **`proof fn lemma_scale_congruence`** — [vec2/ops.rs:85](./src/vec2/ops.rs#L85)
  > a ≡ b implies scale(s, a) ≡ scale(s, b)
- **`proof fn lemma_scale_associative`** — [vec2/ops.rs:96](./src/vec2/ops.rs#L96)
  > scale(s, scale(t, a)) ≡ scale(s * t, a)
- **`proof fn lemma_scale_neg_scalar`** — [vec2/ops.rs:108](./src/vec2/ops.rs#L108)
  > scale(-s, a) ≡ -scale(s, a)
- **`proof fn lemma_scale_neg_vec`** — [vec2/ops.rs:117](./src/vec2/ops.rs#L117)
  > scale(s, -a) ≡ -scale(s, a)
- **`proof fn lemma_scale_sub_distributes`** — [vec2/ops.rs:126](./src/vec2/ops.rs#L126)
  > scale(s, a - b) ≡ scale(s, a) - scale(s, b)
- **`proof fn lemma_dot_commutative`** — [vec2/ops.rs:139](./src/vec2/ops.rs#L139)
  > dot(a, b) ≡ dot(b, a)
- **`proof fn lemma_dot_zero_right`** — [vec2/ops.rs:152](./src/vec2/ops.rs#L152)
  > dot(a, zero) ≡ 0
- **`proof fn lemma_dot_zero_left`** — [vec2/ops.rs:171](./src/vec2/ops.rs#L171)
  > dot(zero, a) ≡ 0
- **`proof fn lemma_dot_distributes_right`** — [vec2/ops.rs:190](./src/vec2/ops.rs#L190)
  > dot(a, b + c) ≡ dot(a, b) + dot(a, c)
- **`proof fn lemma_dot_distributes_left`** — [vec2/ops.rs:215](./src/vec2/ops.rs#L215)
  > dot(a + b, c) ≡ dot(a, c) + dot(b, c)
- **`proof fn lemma_dot_scale_left`** — [vec2/ops.rs:240](./src/vec2/ops.rs#L240)
  > dot(scale(s, a), b) ≡ s * dot(a, b)
- **`proof fn lemma_dot_scale_right`** — [vec2/ops.rs:268](./src/vec2/ops.rs#L268)
  > dot(a, scale(s, b)) ≡ s * dot(a, b)
- **`proof fn lemma_dot_congruence`** — [vec2/ops.rs:296](./src/vec2/ops.rs#L296)
  > a1 ≡ a2, b1 ≡ b2 implies dot(a1, b1) ≡ dot(a2, b2)
- **`proof fn lemma_dot_neg_right`** — [vec2/ops.rs:312](./src/vec2/ops.rs#L312)
  > dot(a, -b) ≡ -dot(a, b)
- **`proof fn lemma_norm_sq_congruence`** — [vec2/ops.rs:344](./src/vec2/ops.rs#L344)
  > a ≡ b implies norm_sq(a) ≡ norm_sq(b)
- **`proof fn lemma_norm_sq_scale`** — [vec2/ops.rs:354](./src/vec2/ops.rs#L354)
  > norm_sq(scale(s, v)) ≡ s*s * norm_sq(v)
- **`proof fn lemma_norm_sq_nonneg`** — [vec2/ops.rs:380](./src/vec2/ops.rs#L380)
  > 0 ≤ norm_sq(v)
- **`proof fn lemma_norm_sq_zero_implies_zero`** — [vec2/ops.rs:388](./src/vec2/ops.rs#L388)
  > norm_sq(v) ≡ 0 implies v ≡ zero (for OrderedField)
- **`proof fn lemma_norm_sq_zero_of_zero`** — [vec2/ops.rs:398](./src/vec2/ops.rs#L398)
  > v ≡ zero implies norm_sq(v) ≡ 0
- **`proof fn lemma_lerp_zero`** — [vec2/ops.rs:415](./src/vec2/ops.rs#L415)
  > lerp(a, b, 0) ≡ a
- **`proof fn lemma_lerp_one`** — [vec2/ops.rs:469](./src/vec2/ops.rs#L469)
  > lerp(a, b, 1) ≡ b
- **`proof fn lemma_lerp_self`** — [vec2/ops.rs:512](./src/vec2/ops.rs#L512)
  > lerp(a, a, t) ≡ a
- **`proof fn lemma_pythagorean`** — [vec2/ops.rs:622](./src/vec2/ops.rs#L622)
  > Pythagorean theorem: if dot(a,b) ≡ 0, then norm_sq(a+b) ≡ norm_sq(a) + norm_sq(b)
- **`proof fn lemma_parallelogram`** — [vec2/ops.rs:724](./src/vec2/ops.rs#L724)
  > Parallelogram law: norm_sq(a+b) + norm_sq(a-b) ≡ 2·(norm_sq(a) + norm_sq(b))
- **`proof fn lemma_polarization`** — [vec2/ops.rs:816](./src/vec2/ops.rs#L816)
  > Polarization identity: 4·dot(a,b) ≡ norm_sq(a+b) - norm_sq(a-b)
- **`proof fn lemma_cauchy_schwarz`** — [vec2/ops.rs:917](./src/vec2/ops.rs#L917)
  > dot(a,b)² <= norm_sq(a) * norm_sq(b)
- **`proof fn lemma_proj_rej_decomposition`** — [vec2/ops.rs:972](./src/vec2/ops.rs#L972)
  > proj(a, b) + rej(a, b) ≡ a
- **`proof fn lemma_rej_orthogonal`** — [vec2/ops.rs:988](./src/vec2/ops.rs#L988)
  > dot(rej(a, b), b) ≡ 0
- **`proof fn lemma_proj_rej_pythagorean`** — [vec2/ops.rs:1034](./src/vec2/ops.rs#L1034)
  > norm_sq(a) ≡ norm_sq(proj(a,b)) + norm_sq(rej(a,b))
- **`proof fn lemma_proj_idempotent`** — [vec2/ops.rs:1088](./src/vec2/ops.rs#L1088)
  > proj(proj(a, b), b) ≡ proj(a, b)
- **`proof fn lemma_proj_zero_when_orthogonal`** — [vec2/ops.rs:1117](./src/vec2/ops.rs#L1117)
  > proj(a, b) ≡ zero when dot(a, b) ≡ 0
- **`proof fn lemma_cwise_min_le_left`** — [vec2/ops.rs:1156](./src/vec2/ops.rs#L1156)
  > Each component of cwise_min(a, b) ≤ corresponding component of a
- **`proof fn lemma_cwise_min_le_right`** — [vec2/ops.rs:1166](./src/vec2/ops.rs#L1166)
  > Each component of cwise_min(a, b) ≤ corresponding component of b
- **`proof fn lemma_cwise_max_ge_left`** — [vec2/ops.rs:1176](./src/vec2/ops.rs#L1176)
  > Each component of a ≤ corresponding component of cwise_max(a, b)
- **`proof fn lemma_cwise_max_ge_right`** — [vec2/ops.rs:1186](./src/vec2/ops.rs#L1186)
  > Each component of b ≤ corresponding component of cwise_max(a, b)

## `vec3::Vec3<T>`

### Spec Functions

- **`open spec fn new`** — [vec3.rs:16](./src/vec3.rs#L16)

## `vec3::ops`

### Spec Functions

- **`open spec fn scale`** — [vec3/ops.rs:19](./src/vec3/ops.rs#L19)
- **`open spec fn dot`** — [vec3/ops.rs:23](./src/vec3/ops.rs#L23)
- **`open spec fn norm_sq`** — [vec3/ops.rs:27](./src/vec3/ops.rs#L27)
- **`open spec fn lerp`** — [vec3/ops.rs:31](./src/vec3/ops.rs#L31)
- **`open spec fn cross`** — [vec3/ops.rs:35](./src/vec3/ops.rs#L35)
- **`open spec fn triple`** — [vec3/ops.rs:43](./src/vec3/ops.rs#L43)
- **`open spec fn proj`** — [vec3/ops.rs:2614](./src/vec3/ops.rs#L2614)
  > Projection of a onto b
- **`open spec fn rej`** — [vec3/ops.rs:2619](./src/vec3/ops.rs#L2619)
  > Rejection of a from b (component of a orthogonal to b)
- **`open spec fn cwise_min`** — [vec3/ops.rs:2813](./src/vec3/ops.rs#L2813)
- **`open spec fn cwise_max`** — [vec3/ops.rs:2821](./src/vec3/ops.rs#L2821)

### Proof Functions

- **`proof fn lemma_scale_distributes_over_add`** — [vec3/ops.rs:52](./src/vec3/ops.rs#L52)
  > scale(s, a + b) ≡ scale(s, a) + scale(s, b)
- **`proof fn lemma_scale_add_distributes`** — [vec3/ops.rs:62](./src/vec3/ops.rs#L62)
  > scale(s + t, a) ≡ scale(s, a) + scale(t, a)
- **`proof fn lemma_scale_identity`** — [vec3/ops.rs:72](./src/vec3/ops.rs#L72)
  > scale(1, a) ≡ a
- **`proof fn lemma_scale_zero_scalar`** — [vec3/ops.rs:82](./src/vec3/ops.rs#L82)
  > scale(0, a) ≡ zero
- **`proof fn lemma_scale_zero_vec`** — [vec3/ops.rs:92](./src/vec3/ops.rs#L92)
  > scale(s, zero) ≡ zero
- **`proof fn lemma_scale_congruence`** — [vec3/ops.rs:101](./src/vec3/ops.rs#L101)
  > a ≡ b implies scale(s, a) ≡ scale(s, b)
- **`proof fn lemma_scale_associative`** — [vec3/ops.rs:113](./src/vec3/ops.rs#L113)
  > scale(s, scale(t, a)) ≡ scale(s * t, a)
- **`proof fn lemma_scale_neg_scalar`** — [vec3/ops.rs:126](./src/vec3/ops.rs#L126)
  > scale(-s, a) ≡ -scale(s, a)
- **`proof fn lemma_scale_neg_vec`** — [vec3/ops.rs:136](./src/vec3/ops.rs#L136)
  > scale(s, -a) ≡ -scale(s, a)
- **`proof fn lemma_scale_sub_distributes`** — [vec3/ops.rs:146](./src/vec3/ops.rs#L146)
  > scale(s, a - b) ≡ scale(s, a) - scale(s, b)
- **`proof fn lemma_dot_commutative`** — [vec3/ops.rs:160](./src/vec3/ops.rs#L160)
  > dot(a, b) ≡ dot(b, a)
- **`proof fn lemma_dot_zero_right`** — [vec3/ops.rs:180](./src/vec3/ops.rs#L180)
  > dot(a, zero) ≡ 0
- **`proof fn lemma_dot_zero_left`** — [vec3/ops.rs:214](./src/vec3/ops.rs#L214)
  > dot(zero, a) ≡ 0
- **`proof fn lemma_dot_distributes_right`** — [vec3/ops.rs:248](./src/vec3/ops.rs#L248)
  > dot(a, b + c) ≡ dot(a, b) + dot(a, c)
- **`proof fn lemma_dot_distributes_left`** — [vec3/ops.rs:305](./src/vec3/ops.rs#L305)
  > dot(a + b, c) ≡ dot(a, c) + dot(b, c)
- **`proof fn lemma_dot_scale_left`** — [vec3/ops.rs:359](./src/vec3/ops.rs#L359)
  > dot(scale(s, a), b) ≡ s * dot(a, b)
- **`proof fn lemma_dot_scale_right`** — [vec3/ops.rs:415](./src/vec3/ops.rs#L415)
  > dot(a, scale(s, b)) ≡ s * dot(a, b)
- **`proof fn lemma_cross_anticommutative`** — [vec3/ops.rs:440](./src/vec3/ops.rs#L440)
  > cross(a, b) ≡ -cross(b, a)
- **`proof fn lemma_cross_self_zero`** — [vec3/ops.rs:500](./src/vec3/ops.rs#L500)
  > cross(a, a) ≡ zero
- **`proof fn lemma_cross_distributes_right`** — [vec3/ops.rs:566](./src/vec3/ops.rs#L566)
  > cross(a, b + c) ≡ cross(a, b) + cross(a, c)
- **`proof fn lemma_cross_distributes_left`** — [vec3/ops.rs:614](./src/vec3/ops.rs#L614)
  > cross(a + b, c) ≡ cross(a, c) + cross(b, c)
- **`proof fn lemma_cross_scale`** — [vec3/ops.rs:662](./src/vec3/ops.rs#L662)
  > cross(scale(s, a), b) ≡ scale(s, cross(a, b))
- **`proof fn lemma_cross_orthogonal_left`** — [vec3/ops.rs:755](./src/vec3/ops.rs#L755)
  > dot(cross(a, b), a) ≡ 0
- **`proof fn lemma_cross_orthogonal_right`** — [vec3/ops.rs:956](./src/vec3/ops.rs#L956)
  > dot(cross(a, b), b) ≡ 0
- **`proof fn lemma_dot_congruence`** — [vec3/ops.rs:1098](./src/vec3/ops.rs#L1098)
  > a1 ≡ a2, b1 ≡ b2 implies dot(a1, b1) ≡ dot(a2, b2)
- **`proof fn lemma_dot_neg_right`** — [vec3/ops.rs:1121](./src/vec3/ops.rs#L1121)
  > dot(a, -b) ≡ -dot(a, b)
- **`proof fn lemma_norm_sq_congruence`** — [vec3/ops.rs:1174](./src/vec3/ops.rs#L1174)
  > a ≡ b implies norm_sq(a) ≡ norm_sq(b)
- **`proof fn lemma_norm_sq_scale`** — [vec3/ops.rs:1184](./src/vec3/ops.rs#L1184)
  > norm_sq(scale(s, v)) ≡ s*s * norm_sq(v)
- **`proof fn lemma_norm_sq_nonneg`** — [vec3/ops.rs:1206](./src/vec3/ops.rs#L1206)
  > 0 ≤ norm_sq(v)
- **`proof fn lemma_norm_sq_zero_implies_zero`** — [vec3/ops.rs:1214](./src/vec3/ops.rs#L1214)
  > norm_sq(v) ≡ 0 implies v ≡ zero (for OrderedField)
- **`proof fn lemma_norm_sq_zero_of_zero`** — [vec3/ops.rs:1224](./src/vec3/ops.rs#L1224)
  > v ≡ zero implies norm_sq(v) ≡ 0
- **`proof fn lemma_triple_self_zero_23`** — [vec3/ops.rs:1241](./src/vec3/ops.rs#L1241)
  > triple(a, b, b) ≡ 0
- **`proof fn lemma_triple_self_zero_12`** — [vec3/ops.rs:1309](./src/vec3/ops.rs#L1309)
  > triple(a, a, b) ≡ 0
- **`proof fn lemma_triple_self_zero_13`** — [vec3/ops.rs:1322](./src/vec3/ops.rs#L1322)
  > triple(a, b, a) ≡ 0
- **`proof fn lemma_triple_linear_first`** — [vec3/ops.rs:1335](./src/vec3/ops.rs#L1335)
  > triple(a + a2, b, c) ≡ triple(a, b, c) + triple(a2, b, c)
- **`proof fn lemma_triple_swap_12`** — [vec3/ops.rs:1343](./src/vec3/ops.rs#L1343)
  > triple(a, b, c) ≡ -triple(b, a, c) (swap first two)
- **`proof fn lemma_triple_swap_23`** — [vec3/ops.rs:1461](./src/vec3/ops.rs#L1461)
  > triple(a, c, b) ≡ -triple(a, b, c) (swap last two)
- **`proof fn lemma_triple_cyclic`** — [vec3/ops.rs:1480](./src/vec3/ops.rs#L1480)
  > triple(a, b, c) ≡ triple(b, c, a) (cyclic permutation)
- **`proof fn lemma_lagrange_identity`** — [vec3/ops.rs:1804](./src/vec3/ops.rs#L1804)
  > Lagrange identity: ‖a × b‖² ≡ ‖a‖²·‖b‖² − (a · b)²  Uses dimensional reduction: the 3D identity reduces to the 2D Lagrange identity (for the cz component) plus pair_expansion (for cx, cy).
- **`proof fn lemma_lerp_zero`** — [vec3/ops.rs:2100](./src/vec3/ops.rs#L2100)
  > lerp(a, b, 0) ≡ a
- **`proof fn lemma_lerp_one`** — [vec3/ops.rs:2161](./src/vec3/ops.rs#L2161)
  > lerp(a, b, 1) ≡ b
- **`proof fn lemma_lerp_self`** — [vec3/ops.rs:2211](./src/vec3/ops.rs#L2211)
  > lerp(a, a, t) ≡ a
- **`proof fn lemma_pythagorean`** — [vec3/ops.rs:2315](./src/vec3/ops.rs#L2315)
  > Pythagorean theorem: if dot(a,b) ≡ 0, then norm_sq(a+b) ≡ norm_sq(a) + norm_sq(b)
- **`proof fn lemma_parallelogram`** — [vec3/ops.rs:2404](./src/vec3/ops.rs#L2404)
  > Parallelogram law: norm_sq(a+b) + norm_sq(a-b) ≡ 2·(norm_sq(a) + norm_sq(b))
- **`proof fn lemma_polarization`** — [vec3/ops.rs:2489](./src/vec3/ops.rs#L2489)
  > Polarization identity: 4·dot(a,b) ≡ norm_sq(a+b) - norm_sq(a-b)
- **`proof fn lemma_cauchy_schwarz`** — [vec3/ops.rs:2584](./src/vec3/ops.rs#L2584)
  > dot(a,b)² <= norm_sq(a) * norm_sq(b)
- **`proof fn lemma_proj_rej_decomposition`** — [vec3/ops.rs:2655](./src/vec3/ops.rs#L2655)
  > proj(a, b) + rej(a, b) ≡ a
- **`proof fn lemma_rej_orthogonal`** — [vec3/ops.rs:2670](./src/vec3/ops.rs#L2670)
  > dot(rej(a, b), b) ≡ 0
- **`proof fn lemma_proj_rej_pythagorean`** — [vec3/ops.rs:2711](./src/vec3/ops.rs#L2711)
  > norm_sq(a) ≡ norm_sq(proj(a,b)) + norm_sq(rej(a,b))
- **`proof fn lemma_proj_idempotent`** — [vec3/ops.rs:2755](./src/vec3/ops.rs#L2755)
  > proj(proj(a, b), b) ≡ proj(a, b)
- **`proof fn lemma_proj_zero_when_orthogonal`** — [vec3/ops.rs:2782](./src/vec3/ops.rs#L2782)
  > proj(a, b) ≡ zero when dot(a, b) ≡ 0
- **`proof fn lemma_cwise_min_le_left`** — [vec3/ops.rs:2830](./src/vec3/ops.rs#L2830)
  > Each component of cwise_min(a, b) ≤ corresponding component of a
- **`proof fn lemma_cwise_min_le_right`** — [vec3/ops.rs:2842](./src/vec3/ops.rs#L2842)
  > Each component of cwise_min(a, b) ≤ corresponding component of b
- **`proof fn lemma_cwise_max_ge_left`** — [vec3/ops.rs:2854](./src/vec3/ops.rs#L2854)
  > Each component of a ≤ corresponding component of cwise_max(a, b)
- **`proof fn lemma_cwise_max_ge_right`** — [vec3/ops.rs:2866](./src/vec3/ops.rs#L2866)
  > Each component of b ≤ corresponding component of cwise_max(a, b)

## `vec4::Vec4<T>`

### Spec Functions

- **`open spec fn new`** — [vec4.rs:17](./src/vec4.rs#L17)

## `vec4::ops`

### Spec Functions

- **`open spec fn scale`** — [vec4/ops.rs:18](./src/vec4/ops.rs#L18)
- **`open spec fn dot`** — [vec4/ops.rs:22](./src/vec4/ops.rs#L22)
- **`open spec fn norm_sq`** — [vec4/ops.rs:26](./src/vec4/ops.rs#L26)
- **`open spec fn lerp`** — [vec4/ops.rs:30](./src/vec4/ops.rs#L30)
- **`open spec fn cwise_min`** — [vec4/ops.rs:1292](./src/vec4/ops.rs#L1292)
- **`open spec fn cwise_max`** — [vec4/ops.rs:1301](./src/vec4/ops.rs#L1301)

### Proof Functions

- **`proof fn lemma_scale_distributes_over_add`** — [vec4/ops.rs:39](./src/vec4/ops.rs#L39)
  > scale(s, a + b) ≡ scale(s, a) + scale(s, b)
- **`proof fn lemma_scale_add_distributes`** — [vec4/ops.rs:50](./src/vec4/ops.rs#L50)
  > scale(s + t, a) ≡ scale(s, a) + scale(t, a)
- **`proof fn lemma_scale_identity`** — [vec4/ops.rs:61](./src/vec4/ops.rs#L61)
  > scale(1, a) ≡ a
- **`proof fn lemma_scale_zero_scalar`** — [vec4/ops.rs:72](./src/vec4/ops.rs#L72)
  > scale(0, a) ≡ zero
- **`proof fn lemma_scale_zero_vec`** — [vec4/ops.rs:85](./src/vec4/ops.rs#L85)
  > scale(s, zero) ≡ zero
- **`proof fn lemma_scale_congruence`** — [vec4/ops.rs:94](./src/vec4/ops.rs#L94)
  > a ≡ b implies scale(s, a) ≡ scale(s, b)
- **`proof fn lemma_scale_associative`** — [vec4/ops.rs:107](./src/vec4/ops.rs#L107)
  > scale(s, scale(t, a)) ≡ scale(s * t, a)
- **`proof fn lemma_scale_neg_scalar`** — [vec4/ops.rs:122](./src/vec4/ops.rs#L122)
  > scale(-s, a) ≡ -scale(s, a)
- **`proof fn lemma_scale_neg_vec`** — [vec4/ops.rs:133](./src/vec4/ops.rs#L133)
  > scale(s, -a) ≡ -scale(s, a)
- **`proof fn lemma_scale_sub_distributes`** — [vec4/ops.rs:144](./src/vec4/ops.rs#L144)
  > scale(s, a - b) ≡ scale(s, a) - scale(s, b)
- **`proof fn lemma_dot_commutative`** — [vec4/ops.rs:159](./src/vec4/ops.rs#L159)
  > dot(a, b) ≡ dot(b, a)
- **`proof fn lemma_dot_zero_right`** — [vec4/ops.rs:186](./src/vec4/ops.rs#L186)
  > dot(a, zero) ≡ 0
- **`proof fn lemma_dot_zero_left`** — [vec4/ops.rs:233](./src/vec4/ops.rs#L233)
  > dot(zero, a) ≡ 0
- **`proof fn lemma_dot_distributes_right`** — [vec4/ops.rs:280](./src/vec4/ops.rs#L280)
  > dot(a, b + c) ≡ dot(a, b) + dot(a, c)
- **`proof fn lemma_dot_distributes_left`** — [vec4/ops.rs:369](./src/vec4/ops.rs#L369)
  > dot(a + b, c) ≡ dot(a, c) + dot(b, c)
- **`proof fn lemma_dot_scale_left`** — [vec4/ops.rs:450](./src/vec4/ops.rs#L450)
  > dot(scale(s, a), b) ≡ s * dot(a, b)
- **`proof fn lemma_dot_scale_right`** — [vec4/ops.rs:534](./src/vec4/ops.rs#L534)
  > dot(a, scale(s, b)) ≡ s * dot(a, b)
- **`proof fn lemma_dot_congruence`** — [vec4/ops.rs:559](./src/vec4/ops.rs#L559)
  > a1 ≡ a2, b1 ≡ b2 implies dot(a1, b1) ≡ dot(a2, b2)
- **`proof fn lemma_dot_neg_right`** — [vec4/ops.rs:589](./src/vec4/ops.rs#L589)
  > dot(a, -b) ≡ -dot(a, b)
- **`proof fn lemma_norm_sq_congruence`** — [vec4/ops.rs:668](./src/vec4/ops.rs#L668)
  > a ≡ b implies norm_sq(a) ≡ norm_sq(b)
- **`proof fn lemma_norm_sq_scale`** — [vec4/ops.rs:678](./src/vec4/ops.rs#L678)
  > norm_sq(scale(s, v)) ≡ s*s * norm_sq(v)
- **`proof fn lemma_norm_sq_nonneg`** — [vec4/ops.rs:700](./src/vec4/ops.rs#L700)
  > 0 ≤ norm_sq(v)
- **`proof fn lemma_norm_sq_zero_implies_zero`** — [vec4/ops.rs:716](./src/vec4/ops.rs#L716)
  > norm_sq(v) ≡ 0 implies v ≡ zero (for OrderedField)
- **`proof fn lemma_norm_sq_zero_of_zero`** — [vec4/ops.rs:759](./src/vec4/ops.rs#L759)
  > v ≡ zero implies norm_sq(v) ≡ 0
- **`proof fn lemma_lerp_zero`** — [vec4/ops.rs:776](./src/vec4/ops.rs#L776)
  > lerp(a, b, 0) ≡ a
- **`proof fn lemma_lerp_one`** — [vec4/ops.rs:848](./src/vec4/ops.rs#L848)
  > lerp(a, b, 1) ≡ b
- **`proof fn lemma_lerp_self`** — [vec4/ops.rs:909](./src/vec4/ops.rs#L909)
  > lerp(a, a, t) ≡ a
- **`proof fn lemma_pythagorean`** — [vec4/ops.rs:1016](./src/vec4/ops.rs#L1016)
  > Pythagorean theorem: if dot(a,b) ≡ 0, then norm_sq(a+b) ≡ norm_sq(a) + norm_sq(b)
- **`proof fn lemma_parallelogram`** — [vec4/ops.rs:1105](./src/vec4/ops.rs#L1105)
  > Parallelogram law: norm_sq(a+b) + norm_sq(a-b) ≡ 2·(norm_sq(a) + norm_sq(b))
- **`proof fn lemma_polarization`** — [vec4/ops.rs:1190](./src/vec4/ops.rs#L1190)
  > Polarization identity: 4·dot(a,b) ≡ norm_sq(a+b) - norm_sq(a-b)
- **`proof fn lemma_cauchy_schwarz`** — [vec4/ops.rs:1281](./src/vec4/ops.rs#L1281)
  > Cauchy-Schwarz inequality: dot(a,b)² ≤ norm_sq(a) · norm_sq(b)
- **`proof fn lemma_cwise_min_le_left`** — [vec4/ops.rs:1311](./src/vec4/ops.rs#L1311)
  > Each component of cwise_min(a, b) ≤ corresponding component of a
- **`proof fn lemma_cwise_min_le_right`** — [vec4/ops.rs:1325](./src/vec4/ops.rs#L1325)
  > Each component of cwise_min(a, b) ≤ corresponding component of b
- **`proof fn lemma_cwise_max_ge_left`** — [vec4/ops.rs:1339](./src/vec4/ops.rs#L1339)
  > Each component of a ≤ corresponding component of cwise_max(a, b)
- **`proof fn lemma_cwise_max_ge_right`** — [vec4/ops.rs:1353](./src/vec4/ops.rs#L1353)
  > Each component of b ≤ corresponding component of cwise_max(a, b)

